---
title: "**`criticalpath`**: Método do Caminho Crítico em **R**"
author: "Rubens José Rosa, Marcos dos Santos, Thiago Marques"
date: 24/01/2022
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  collapse = TRUE,
  comment = "#>"
)
```


> O objetivo desse e-book é mostrar como utilizar o pacote `criticalpath`.




```{r}
library(criticalpath)
library(tibble)
```


Para criar um cronograma, você deve fornecer um título, a referência sobre a origem sua origem (livro, artigo, empresa), a lista de atividades e a lista de relacionamentos.

Com base nas informações fornecidas, o pacote `criticalpath` aplica o método do caminho crítico, calculando as informações relativas ao projeto.

O objetivo deste texto é mostrar como se utiliza o pacote `criticalpath`, descrevendo suas propriedades e suas funções.


# Formas de representar um cronograma


Quando você vai criar um cronograma, normalmente já existe um esboço dele. Da mesma forma, na litaretura você vê várias formas de representar um cronograma.
Aqui vamos mostrar algumas formas retirada da literatura, na sequência vamos ver como podemos criar cronogramas no **R**.


> Fazer a tabela de atividades com suas predecessoras

Essa representação é uma tabela, sendo que cada linha representa uma atividade, com identificador, nome, duração e lista de identificadores das atividades **predecessoras**.

A ordem das linhas na tabela não importa para o pacote `criticalpath`, mas é importante manter uma ordem para o nosso entendimento, tanto do gerente de projeto, como das pessoas que irão visualizar o cronograma.



> Fazer a tabela de atividade com suas sucessoras

A única diferença entre esta representação e a anterior, é que aqui são mostradas a lista de identificadores das atividades sucessoras.

Considerando que cada atividade aparece antes da sua sucessora, é importante destacar que após a criação de todo o cronograma, devem existir todas atividades com identificadores relacionadas na coluna sucessora.


# Propriedade do cronograma

FALAR DO SCH, que É UM ESPAÇO NA MEMÓRIA ONDE GUARDAMOS O CRONOGRAMA.

Informações que podemos obter de um cronograma utilizando o pacote `criticalpath`.




- **title:** O título ou nome do projeto que está sob análise. Esse título depende do usuário da classe, pois ele deve identificar um projeto real ou algum experimento. 
Utilização:
   - `sch_title(sch, "O Título")`: altera o título do projeto.
   - `sch_title(sch)`: recupera o título do projeto.

- **reference:** A referência da origem do projeto, por exemplo, um livro, um artigo uma corporação ou, se não puder ser identificada, não precisa colocar nada.
   - `sch_reference(sch, "A referência.")`: altera a referência do projeto.
   - `sch_reference(sch)`: recupera a referência do projeto.

- **duration:** Um valor inteiro que indica a duração do projeto calculada pelo CPM. A duração e todos os outros valores do método do caminho crítico são calculados após a chamada à função `sch_plan(sch)`.
   - `sch_duration(sch)`: recupera a duração do projeto.
   




# Propriedades das atividades

As atividades são colocadas numa tabela, que no **R** é chamada de data-frame. Cada propriedade das atividades é colocada numa coluna do data-frame. Segue a descrição de cada uma delas.

- `id`: Identificador da atividade. É um número inteiro que deve ser único em todo o cronograma: não pode haver duas atividades como o mesmo identificador.
Esse identificador será utilizado para fazer o relacionamento entre as atividades. É obrigatório informar um identificador para a atividade.

- `name`: Nome da atividade. Se não for informado, fica um string vazio.

- `duration`: Duração da atividade. Seu formato deve ser um número inteiro, maior ou igual a zero. Ele é um número independente de unidade de tempo. O pacote `criticalpath` interpreta como período, que pode ser dias, horas, minutos ou segundos. Se não for informado, será zero.

- `milestone`: Indica se a atividade é um marco ou não. Um marco (*milestone*) é uma atividade com duração zero. 
  - `TRUE`: indica que é um marco;
  - `FALSE`: indica que não é um marco.
     
- `critical`: Indica se a atividade é crítica ou não. Uma atividade é crítica se sua folga total é menor ou igual a zero. 
  - `TRUE` indica que a atividade é crítica;
  - `FALSE` indica que a atividade não é crítica.
     
- `ES` - Início mais cedo (_early start_): período de início mais cedo que uma atividade pode iniciar com a condição de que todas as suas predecessoras já tenham sido finalizadas.

- `EF`: Término mais cedo (_early finish_): é a duração da atividade adicionada ao seu início mais cedo.

- `LS`: Início mais tarde (_late start_): é o término mais tarde da atividade menos a sua duração.

- `LF`: Término mais tarde (_late finish_): período de término mais tarde que uma atividade pode finalizar com a condição de que não se sobreponha às suas sucessoras.

- `total_float`: folga total: Quantidade de períodos que uma atividade pode atrasar sem aumentar a duração do projeto.

- `free_float`: folhga livre: Quantidade de períodos que uma atividade pode atrasar sem atrasar nenhuma atividade sucessora dela.

- `progr_level`: nível progressivo: Ordem em que a atividade aparece no diagrama de rede, contada a partir das primeiras atividades. As atividades que não possuem predecessoras tem nível progressivel igual a um. O nível das outras atividades é o maior nível progressivo entre as suas predecessoras, mais um. O maior nível das atividades que não possuem sucessoras é chamada de `max_level`.

- `regr_level`: nível regressivo: Ordem em que as atividades aparecem no digrama de rede, contada a partir das últimas atividades. O nível regressivo das atividades que não possuem sucessoras é igual ao `max_level`. O nível das outras atividades é menor valor do nível regressivo de suas sucessoras, menos um.

- `topo_float`: Diferença entre o nível regressivo e o nível progressivo.




# Propriedades dos relacionamentos

Os relacionamentos são colocados numa tabela, que no **R** é chamada de data-frame. tibble com a relação de precedência entre as atividades. Ele é formado pelo identificador da atividade precessora e da sucessora, o tipo e o lag. Segue a descrição de cada uma das colunas do data-frame.

- `from`: de: Identificador da atividade predecessora. Deve existir uma atividade com esse id.

- `to`:para : Identificador da atividade sucessora. Deve existir uma atividade com esse id.

- `type`: tipo: Define o tipo de relacionamento entre as atividades. Seus valores podem ser: FS, FF, SS. O relacionamento padrão é o FS (Término-Início).
  - `FS`: Término-Início: A atividade sucessora só pode começar depois que a predecessora finalizar.
  - `FF`: Término-Término: A atividade sucessora deve finalizar junto com a predecessora.
  - `SS`: Início-Início: A atividade sucessora deve iniciar junto com a predecessora.
  - `SF`: Início-Término: A atividade sucessora deve finalizar quando a predecessora iniciar.

- `lag`: Intervalo de tempo que a atividade sucessora deve esperar, ou adiantar, para ser executada. Por exemplo, num relacionamento FS, com `lag = 4`, após a predecessora finalizar, a sucessora deve esperar 4 períodos. Em outras palavras, a atividade sucessora avança 4 períodos após o término da predecessora. Se o valor for negativo, a atividade sucessora antecipa seu início. No exemplo acima, se `lag = -4`, a atividade sucessora adiantaria em 4 períodos o seu início. Por padrão, `lag = 0`.



# Relatórios em Rmarkdown

- http://www.leg.ufpr.br/~fernandomayer/palestra/useR-2015/Rmarkdown-rautu.html
- https://prdm0.github.io/aulas_computacional/relat%C3%B3rio-markdown-em-r.html

# Introdução

## Por que fazer isso em **R**?

O **R** é um ambiente estatísticos utilizado para fazer análise de dados de vários tipos de experimentos. Uma das ferramentas do GERENCIAMENTO DE PROJETOS é o *Design of Experiment (DOE)*. Então, esse pacote foi criado para permitir que gerentes de projetos pesquisadores possam fazer seus experimentos com o método do caminho crítico.

## Qual é o público alvo?

> Pegar o público alvo do **Projetos no Prazo**.

- O público alvo desse pacote são gerentes de projetos pesquisadores.
- Também é público alvo os pesquisadores que já conhecem o **R** e desejam conhecer sobre o CPM e como fazer experimentos.

## Pensamentos ainda

Esse documento será uma mescla do vignette `criticalpath` e da minha dissertação.

> Hum, talvez não misturar aqui coisas da minha dissertação!!!

> Ao final da leitura e **prática** desse e-book, o gerente de projeto estará apto a criar cronogramas e aplicar o método do caminho crítico no `R` utilizando o pacote `criticalpath`.

Para isso, é necessário possuir conhecimento em duas áreas diferentes:

- gerenciamento do cronograma do projeto: atividades, relacionamentos e caminho crítco;
- **R**: saber analisar dados com **R**.

Aqui, vamos apenas falar sobre o método do caminho crítico. Não vamos falar sobre a área de gerenciamento de projetos em si.

Como esse e-book pode resolver essa parada?

    > Explicando sobre os dois temas, em capítulos separados.
    
      - Um capítulo sobre o **R**, o mínimo necessário
      - Um capítulo sobre gerenciamento do cronograma
      - Um capítulo, finalmente, sobre casos de uso do pacote `criticalpath`
      - Fora esse capítulo que fala de todos os comandos do pacote.

Outra forma de fazer seria mesclar os conceitos: exeplica uma parte do CPM, explica como aplicar o conceito em *R*.

Poderia mostrar também vários estudos de caso retirados dos livros.

Um cronograma é uma sequência de atividades que têm que ser executadas uma a uma.
Para informar qual atividade vem antes e qual depois, é necessário criar relacionamento entre as atividades. Esses relacionamentos são criados através de números, aqui chamado de identificador da atividades (`id`). É o CPF da atividade. Dentro de um cronograma, não pode haver duas atividades como o mesmo `id`. Esse identificador pode ser sequencial ou totalmente aleatório, desde que ele identifique a qual atividade pertence.



## Método do Caminho Crítico - Critical Path Method - CPM

O pacote **criticalpath** é uma implementação orientada à objetos em **R** do
método do caminho crítico (*Critical Path Method* - CPM), utilizando o pacote **R6**.
O CPM é um método utilizado para estimar a duração mínima de um projeto e também calcular
o quão flexível é a rede de atividades do cronograma. A flexibilidade é em termos do
início mais cedo, término mais cedo, início mais tarde, término mais tarde, folga total
e folga livre. Além disso, com esse pacote é possível quantificar a complexidade do
diagrama de rede através dos indicadores topológicos. Finalmente, o **criticalpath**
permite a análise de cenários "e-se", através da alteração da duração das atividades.

Com este pacote e algumas funções do **R**, você pode calcular os seguintes parâmetros do CPM:

- Duração do cronograma;
- Data de início e término mais cedo;
- Data de início e término mais tarde;
- Caminho crítico;
- Atividades críticas;
- Folga total e folga livre;
- Gráfico de Gantt, derivado da matrix de Gantt;
- Análise de cenários "E-se";
- Indicadores topológicos;

O objetivo deste pacote é permitir que pesquisadores utilizem o método do caminho crítico
em suas pesquisas para fazer experimentos com os parâmetros calculados pelo CPM.

## Alguns experimentos que podem seer feitos


- Ao sortear aleatoriamente a duração das atividades,
  – como fica a aparência da curva S associada ao cronograma?
  – qual a distribuição da duração do projeto
  
- Ao retirar aleatoriamente alguns relacionamentos do cronograma,
  – como fica a curva S
  – qual a distribuição da duração do projeto
  
- Qual é a principal diferença entre os dois experimentos acima?
  – Ao sortear a duração das das atividades, não é necessário criar um novo cronograma.
  – Ao sortear ligações para serem retiradas, é necessário criar um novo cronograma a cada nova estrutura sorteada, sem os relacionamentos sorteados.



# O que é um cronograma?

## Explicar é um diagrama de redes

Explicar os conceitos utilizando um diagrama de redes já pronto. Depois mostra como criar um diagrama de rede.

## Explicar o é que um modelo de cronograma

Recorrer ao PMBOK para isso.

> Isso aqui está virando a minha disseração.
  > Acho até que é uma boa ideia. Colocar aqui todas as definições sobre gerenciamento do cronograma.
  
  Vamos ver! Isso acabará tendo tudo o que estava imaginando. Esse e-book é para ser algo a ser distribuído de graça.


# Como criar um cronograma

Você tem as seguintes alternativas para criar um cronograma:

1. criar um cronograma vazio e adiconar atividades nele uma a uma;
1. criar um cronograma vazio, adicionar as atividades e relacionamentos nele;
1. Criar um cronograma vazio e incluir atividades nele ao mesmo tempo em que
inclui os relacionamentos entre elas.
1. Criar um cronograma a partir de um tibble com as atividades 
e um tibble com os relacionamentos.

Vamos discutir cada uma dessas alternativas.


## Incluindo atividades em um cronograma

- `sch_add_activity(id, name, duration)`: inclui uma atividade em um cronograma.

- `sch_add_activities(activities)` : inclui um tibble com as atividades no cronograma.

Utilização:

- `sch_add_activity(id, name, duration)`
- `sch_add_activities(activities)`

Parâmetros:

- `id`: Identificador da atividade. É um número inteiro que deve ser único:
não pode haver duas atividades como o mesmo identificador.
Esse identificador será utilizado para fazer o relacionamento entre as atividades.
- `name`: Nome da atividade. Se não for informado, fica um string vazio.
- `duration`: Duração da atividade. Seu formato deve ser um número inteiro.
Ele é um número independente de unidade de tempo. O pacote `criticalpath` interpreta
como período, que pode ser dias, horas, minutos ou segundos.
Deve ser um valor maior ou igual a zero. Se não for informado, será zero.
- `activities`: É um tibble com as atividades.
Se não for informado, o cronograma será criado sem nenhuma atividade.
A estrutura do tibble está definida no tópico [===>schedule_from_data_frame].

Exemplos:


```{r}
# Atividades adicionadas uma a uma.
sch <- sch_new() %>% 
  sch_add_activity(1L, "Task 1", 5L) %>% 
  sch_add_activity(2L, "Task 2", 6L) %>% 
  sch_add_activity(3L, "Task 3", 8L) %>% 
  sch_add_activity(4L, "Task 4", 6L) %>% 
  sch_add_activity(5L, "Task 5", 9L) %>% 
  sch_add_activity(6L, "Task 6", 3L) %>% 
  sch_add_activity(7L, "Task 7", 4L) %>%
  sch_plan()
  
sch_duration(sch)
sch_activities(sch)

# Atividades incluídas de uma vez
atb <- tibble(
  id        = 1:17,
  name      = paste("a", as.character(1:17), sep=""),
  duration  = c(1L,2L,2L,4L,3L,3L,3L,2L,1L,1L,2L,1L,1L,1L,1L,2L,1L)
)
sch <- sch_new() %>% 
  sch_add_activities_tibble(atb) %>% 
  sch_plan()
sch_duration(sch)
sch_activities(sch)

```


## Incluindo relacionamentos no cronograma

Um cronograma é formado por atividades e o relacionamento entre elas.
Neste tópico vamos ver como fazemos o relacionamento entre as atividades.

- sch_add_relation(from, to, type="FS", lag=0): 
Inclui um relacionamento ao cronograma

- sch_add_relations(relations) : 
Inclui um tibble com vários relacionamentos entre as atividades.

Modo de utilizar:

- sch_add_relation(from, to, type="FS", lag=0)
- sch_add_relations(relations)

Parâmetros: 

- `from`: Identificador da atividade predecessora. Deve existir uma atividade com esse id.
- `to`: Identificador da atividade sucessora. Deve existir uma atividade com esse id.
- `type`: Define o tipo de relacionamento entre as atividades.
Seus valores podem ser: FS, FF, SS. O relacionamento padrão é o FS (Término-Início)

  - **FS:** Término-Início: A atividade sucessora só pode começar depois que a predecessora finalizar.

  - **FF:** Término-Término: A atividade sucessora deve finalizar junto com a predecessora.

  - **SS:** Início-Início: A atividade sucessora deve iniciar junto com a predecessora.

  - **SF:** Início-Término: A atividade sucessora deve finalizar quando ao predecessora iniciar.

- `lag`: Período de tempo que a atividade sucessora deve esperar para ser executada.
Por exemplo, num relacionamento FS, com `lag = 4`, após a predecessora finalizar, a sucessora deve esperar 4 períodos. Em outras palavras, a atividade sucessora avança 4 períodos após o término da predecessora.
Se o valor for negativo, a atividade sucessora antecipa seu início. No exemplo acima, se `lag = -4`, a atividade sucessora adiantaria em 4 períodos o seu início. Por padrão, `lag = 0`

- `relations`: tibble com a relação de precedência entre as atividades. Ele é formado pelo identificador da atividade precessora e da sucessora, o tipo e o lag. Sua estrutura já foi explicada em [schedule_from_data_frame](kkk).

Exemplos:

```{r}
# Primeiro, cria um cronograma vazio.
sch <- sch_new() %>% 
  sch_title("Project 3: Old Carriage House Renovation") %>% 
  sch_reference(
  "VANHOUCKE, Mario. Integrated project management and control:
  first comes the theory, then the practice. Gent: Springer, 2014, p. 11") %>% 
# Segundo, inclui atividades nele.
  sch_add_activity( 1L, "a1" , 2L) %>% 
  sch_add_activity( 2L, "a2" , 2L) %>% 
  sch_add_activity( 3L, "a3" , 4L) %>% 
  sch_add_activity( 4L, "a4" , 3L) %>% 
  sch_add_activity( 5L, "a5" , 4L) %>% 
  sch_add_activity( 6L, "a6" , 1L) %>% 
  sch_add_activity( 7L, "a7" , 1L) %>% 
  sch_add_activity( 8L, "a8" , 1L) %>% 
  sch_add_activity( 9L, "a9" , 1L) %>% 
  sch_add_activity(10L, "a10", 1L) %>% 
  sch_add_activity(11L, "a11", 3L) %>% 
  sch_add_activity(12L, "a12", 2L) %>% 
  sch_add_activity(13L, "a13", 1L) %>% 
  sch_add_activity(14L, "a14", 1L) %>% 
  sch_add_activity(15L, "a15", 2L) %>% 
  sch_add_activity(16L, "a16", 1L) %>% 
  sch_add_activity(17L, "a17", 1L) %>% 
# Finalmente, incluir os relacionamento entre as atividades.
  sch_add_relation(  1L,  2L) %>% 
  sch_add_relation(  2L,  3L) %>% 
  sch_add_relation(  3L,  4L) %>% 
  sch_add_relation(  4L,  5L) %>% 
  sch_add_relation(  5L,  6L) %>% 
  sch_add_relation(  6L,  7L) %>% 
  sch_add_relation(  6L,  8L) %>% 
  sch_add_relation(  6L,  9L) %>% 
  sch_add_relation(  7L, 10L) %>% 
  sch_add_relation(  8L, 10L) %>% 
  sch_add_relation(  9L, 10L) %>% 
  sch_add_relation( 10L, 11L) %>% 
  sch_add_relation( 10L, 13L) %>% 
  sch_add_relation( 11L, 12L) %>% 
  sch_add_relation( 12L, 15L) %>% 
  sch_add_relation( 13L, 14L) %>% 
  sch_add_relation( 14L, 15L) %>% 
  sch_add_relation( 15L, 16L) %>% 
  sch_add_relation( 16L, 17L) %>%
  sch_plan()

sch_duration(sch)
sch_activities(sch)
sch_relations(sch)
```


## Incluindo atividades e relacionamentos ao mesmo tempo

Incluir uma atividade no cronograma ao mesmo tempo em que inclui seus relacionamentos.

Utilização:

- sch_add_activity(id, name, duration, relations_id=c(), direction="succ")

Parâmetros:

- `id`: Identificador da atividade. É um número que deve ser único em todo o cronograma.
Ele será utilizado para fazer os relacionamentos entre as atividades.
- `name`: Nome da atividade.
- `duration`: Duração da atividade. Deve ser um número inteiro, maior ou igual a zero, sem unidade de tempo.
- `relations_id`: Um vetor de identificadores das atividades que serão relacionadas com a atividade que está sendo incluída. O vetor pode ser uma lista de identificadores sucessoras ou identificadores predecessoras.
- `direction`: Indica a direção do relacionamento: "succ" or "pred".
  - **succ:** o vetor `relations_id` contém a lista a lista de sucessoras da atividade.
  - **pred:** o vetor `relations_id` contém a lista a lista de predecessoras da atividade.

Exemplos:

```{r}
# Cria um cronograma
sch <- sch_new() %>% 
  sch_title("Fictitious Project Example") %>% 
  sch_reference("VANHOUCKE, Mario. Measuring time:
  improving project performance using earned value management.
  Gent: Springer, 2009, p. 18") %>% 
# Incluir as atividades e seus relacionamentos nele.
  sch_add_activity(  1L, "a1" , 0L, 2L,3L,4L) %>% 
  sch_add_activity(  2L, "a2" , 4L, 5L) %>% 
  sch_add_activity(  3L, "a3" , 9L, 10L) %>% 
  sch_add_activity(  4L, "a4" , 1L, 6L) %>% 
  sch_add_activity(  5L, "a5" , 4L, 9L) %>% 
  sch_add_activity(  6L, "a6" , 5L, 7L) %>% 
  sch_add_activity(  7L, "a7" , 1L, 8L,11L) %>% 
  sch_add_activity(  8L, "a8" , 7L, 12L) %>% 
  sch_add_activity(  9L, "a9" , 8L, 12L) %>% 
  sch_add_activity( 10L, "a10", 3L, 12L) %>% 
  sch_add_activity( 11L, "a11", 3L, 12L) %>% 
  sch_add_activity( 12L, "a12", 0L) %>% 
  sch_plan()

sch_duration(sch)
sch_activities(sch)
sch_relations(sch)
```



## Criando um cronograma a partir de tibbles [schedule_from_data_frame]

O comando `sch_new(activities, relations)` cria um cronograma a partir de um tibble de atividades e de outro tibble com os relacionamento entre elas.
Após a criação, o pacote *criticalpath* aplica o método do caminho crítico.

É possível criar um cronograma vazio, sem nenhuma atividade e sem nenhum relacionamento com o comando `sch_new()`. Neste caso, é possível incluir atividades com o comando `add_activity` e relacionamentos com o comando `add_relation` methods.

Parâmetros:

- `activities`: tibble com as atividades. Se ele não for informado, o cronograma será criado sem nenhuma atividade.

Sua estrutura é formada pelos seguintes campos:

  - **id:** Identificador da atividade. É um número inteiro que deve ser único:
não pode haver duas atividades como o mesmo identificador.
Esse identificador será utilizado para fazer o relacionamento entre as atividades. 
  - **name:** Nome da atividade. Se não for informado, fica um string vazio.
  - **duration:** Duração da atividade. Seu formato deve ser um número inteiro.
Ele é um número independente de unidade de tempo. O pacote `criticalpath` interpreta
como período, que pode ser dias, horas, minutos ou segundos.
Deve ser um valor maior ou igual a zero. Se não for informado, será zero.


- `relations`: tibble com a relação de precedência entre as atividades. Ele é formado pelo identificador da atividade precessora, pelo identificador da atividade sucessora, o tipo e o lag. Segue a descrição destes elementos:
  - **from:** Identificador da atividade predecessora. Deve existir uma atividade com esse id.
  - **to:**  Identificador da atividade sucessora. Deve existir uma atividade com esse id.
  - **type:** Define o tipo de relacionamento entre as atividades.
Seus valores podem ser: FS, FF, SS. O relacionamento padrão é o FS (Término-Início).
      - **FS:** Término-Início: 
      A atividade sucessora só pode começar depois que a predecessora finalizar.
      - **FF:** Término-Término: 
      A atividade sucessora deve finalizar junto com a predecessora.
      - **SS:** Início-Início: 
      A atividade sucessora deve iniciar junto com a predecessora.
      - **SF:** Início-Término: 
      A atividade sucessora deve finalizar quando ao predecessora iniciar.

  - **lag:** Período de tempo que a atividade sucessora deve esperar para ser executada.
Por exemplo, num relacionamento FS, com `lag = 4`, após a predecessora finalizar, a sucessora deve esperar 4 períodos. Em outras palavras, a atividade sucessora avança 4 períodos após o término da predecessora.
Se o valor for negativo, a atividade sucessora antecipa seu início. No exemplo acima, se `lag = -4`, a atividade sucessora adiantaria em 4 períodos o seu início. Por padrão, `lag = 0`


```{r}

# Cria um cronograma vazio
sch <- sch_new()
###########sch_duration(sch)
sch_activities(sch)
sch_relations(sch)

# Cria um tibble com as atividades.
atb <- tibble(
  id        = 1:17,
  name      = paste("a", as.character(1:17), sep=""),
  duration  = c(1L,2L,2L,4L,3L,3L,3L,2L,1L,1L,2L,1L,1L,1L,1L,2L,1L)
)

# Cria um data com os relacionamentos entre as atividades.
rtb <- data.frame(
  from = c(1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L,  3L,  4L,  5L,  6L,
           7L,  8L,  9L, 10L, 11L, 11L, 12L, 12L, 13L, 13L, 14L, 14L, 15L, 15L),
  to   = c(2L, 3L, 4L, 5L, 6L, 7L, 8L, 9L, 10L, 11L, 11L, 11L,
           12L, 13L, 14L, 15L, 16L, 17L, 16L, 17L, 16L, 17L, 16L, 17L, 16L, 17L)
)
# Cria um cronograma com os tibbles das atividades e dos relacionamentos.
sch <- sch_new() %>% 
  sch_title("Project 1: Cost Information System") %>% 
  sch_reference("VANHOUCKE, Mario.
    Integrated project management and control:
    first comes the theory, then the practice.
    Gent: Springer, 2014, p. 6") %>% 
  sch_add_activities_tibble(atb) %>% 
  sch_add_relations_tibble(rtb) %>% 
  sch_plan()

sch_duration(sch)
sch_activities(sch)
sch_relations(sch)
```


# Como recuperar informações do cronograma

## Título, referência e duração do cronograma


Após a criação de um cronograma, é possível recuperar várias informações dele.

- **title:** O título ou nome do projeto que está sob análise. Esse título depende do usuário da classe, pois ele deve identificar um projeto real ou algum experimento. 
Utilização:

   - `sch_title <- "A title"` : altera o título do projeto.
   - `sch_title` : recupera o título do projeto.

- **reference:** A referência da origem do projeto, por exemplo, um livro, um artigo uma corporação ou, se for confidencial, nada.
   - `sch_reference <- "A reference"`: altera a referência do projeto.
   - `sch_title`: recupera a referência do projeto.

- **duration:** Um valor inteiro que indica a duração do projeto calculada pelo CPM. Cada vez que é incluída uma atividade ou um relacionamento no projeto, a duração e todos os outros valores do método do caminho crítico são calculados.
   - `sch_duration`: recupera a duração do projeto.
   
Exemplos:

```{r}
# Cria um cronograma
sch <- sch_new() %>% 
  sch_title("Fictitious Project Example") %>% 
  sch_reference("VANHOUCKE, Mario. Measuring time:
  improving project performance using earned value management.
  Gent: Springer, 2009, p. 18") %>% 
# Incluir as atividades e seus relacionamentos nele.
  sch_add_activity(  1L, "a1" , 0L, 2L,3L,4L) %>% 
  sch_add_activity(  2L, "a2" , 4L, 5L) %>% 
  sch_add_activity(  3L, "a3" , 9L, 10L) %>% 
  sch_add_activity(  4L, "a4" , 1L, 6L) %>% 
  sch_add_activity(  5L, "a5" , 4L, 9L) %>% 
  sch_add_activity(  6L, "a6" , 5L, 7L) %>% 
  sch_add_activity(  7L, "a7" , 1L, 8L,11L) %>% 
  sch_add_activity(  8L, "a8" , 7L, 12L) %>% 
  sch_add_activity(  9L, "a9" , 8L, 12L) %>% 
  sch_add_activity( 10L, "a10", 3L, 12L) %>% 
  sch_add_activity( 11L, "a11", 3L, 12L) %>% 
  sch_add_activity( 12L, "a12", 0L) %>% 
  sch_plan()
# Consulta os dados do projeto
sch_title(sch)
sch_reference(sch)
sch_duration(sch)
```


# Como recuperar as propriedades das atividades


## Propriedades das atividades

O cronograma possui diversas informações sobre as atividades. 
Após incluir as atividades, você precisa saber quantas foram incluídas, quando cada uma delas está planejada para iniciar ou finalizar. Esta seção explica como você pode recuperar essas e outras informações.

- **Has Any Activity:** Valor lógico que indica se o cronograma possui ou não alguma atividade. 
  - `TRUE`: indica que o cronograma tem pelo menos uma atividade;
  - `FALSE`: indica que o cronograma não possui nenhuma atividade.
  - Utilização: `sch_has_any_activity`

- **Number of Activities:** Indica o número de atividades e o cronograma possui.
   - Utilização: `sch_nr_activities`

- **Get activity:** Recupera uma atividade de acordo com o seu identificador. A estrutura retornada será explicada no próximo tópico.
   - Utilização: `sch_get_activity(id)`

- **Activities:** Retorna um tibble com todas as atividades do cronograma, ordenadas pelo identificador, do menor para o maior. Estas são as principais informações calculadas pelo `criticalpath`. O tibble possui a seguinte estrutura:

   - **id:** Identificador da atividade.
   - **name:** Nome da atividade.
   - **duration:** A duração da atividades.
   - **milestone:** Indica se a atividade é um marco ou não. Um marco (*milestone*) é uma atividade com duração zero. 
     - `TRUE`: indica que é um marco;
     - `FALSE`: indica que não é um marco.
     
   - **critical:** Indica se a atividade é crítica ou não. Uma atividade é crítica se sua folga total é menor ou igual a zero. 
     - `TRUE` indica que a atividade é crítica;
     - `FALSE` indica que a atividade não é crítica.
     
   - **ES:** Início mais cedo: período de início mais cedo que uma atividade pode iniciar com a condição de que todas as suas predecessoras já tenham finalizadas.
   - **EF:** Término mais cedo: é o início mais cedo mais a duração da atividade.
   - **LS:** Início mais tarde: é o término mais tarde menos a duração da atividade.
   - **LF:** Término mais tarde: período de término mais tarde que uma atividade pode finalizar com a condição de que não se sobreponha às suas sucessoras.
   - **total_float:** Quantidade de períodos que uma atividade pode atrasar sem aumentar a duração do projeto.
   - **free_float:** Quantidade de períodos que uma atividade pode atrasar sem atrasar nenhuma atividade sucessora dela.
   - **progr_level:** Ordem em que a atividade aparece no diagrama de rede, contada a partir das primeiras atividades. As atividades que não possuem predecessoras tem nível progressivel igual a um. O nível das outras atividades é o maior nível entre as suas predecessoras, mais um. O maior nível das atividades que não possuem sucessoras é chamada de `max_level`.
   - **regr_level:** Ordem em que as atividades aparecem no digrama de rede, contada a partir das últimas atividades. O nível regressivo das atividades que não possuem sucessoras é igual ao `max_level`. O nível das outras atividades é menor valor do nível regressivo de suas sucessoras, menos um.
   - **topo_float:** Diferença entre o nível regressivo e o nível progressivo.

- Utilização: 
    - `sch_activities`
    - `sch_get_activity(id)`

```{r}
# Create a schedule
sch <- sch_new() %>% 
  sch_title("Fictitious Project Example") %>% 
  sch_reference("VANHOUCKE, Mario. Measuring time:
  improving project performance using earned value management.
  Gent: Springer, 2009, p. 18")

sch_has_any_activity(sch)  # FALSE
sch_nr_activities(sch)     # 0

# Add activities and relations to it.
sch %<>% 
  sch_add_activity(  1L, "a1" , 0L, 2L,3L,4L) %>% 
  sch_add_activity(  2L, "a2" , 4L, 5L) %>% 
  sch_add_activity(  3L, "a3" , 9L, 10L) %>% 
  sch_add_activity(  4L, "a4" , 1L, 6L) %>% 
  sch_add_activity(  5L, "a5" , 4L, 9L) %>% 
  sch_add_activity(  6L, "a6" , 5L, 7L) %>% 
  sch_add_activity(  7L, "a7" , 1L, 8L,11L) %>% 
  sch_add_activity(  8L, "a8" , 7L, 12L) %>% 
  sch_add_activity(  9L, "a9" , 8L, 12L) %>% 
  sch_add_activity( 10L, "a10", 3L, 12L) %>% 
  sch_add_activity( 11L, "a11", 3L, 12L) %>% 
  sch_add_activity( 12L, "a12", 0L)

sch_has_any_activity(sch)  # TRUE
sch_nr_activities(sch)     # 12

sch_get_activity(sch, 10L)
sch_activities(sch)
```

Observação: Nesse cronograma não foi chamado a função `sch_plan(sch)` porque o
objetivo não fazer nenhum cálculo do CPM.

## Matrix de Gantt (Gráfico de Gantt)

Cria uma matriz que representa o gráfico de Gantt do projeto. Na matriz, Um `1` indica que a atividade esta planejada para ser executada no período. Zero `0` indica que ela não está sendo executada.

As linhas representam atividades e as colunas o período de execução do projeto. Então, o número de colunas é igual à duração do projeto.

Utilização:

- `sch_gantt_matrix()`: Retorna a matriz de Gantt.

- `sch_xy_gantt_matrix(gantt=NULL)`: Transforma a matriz de Gantt em coordenadas ordenadas (x, y) e peso um. Cada ponto maior que zero na matriz torna-se uma coordenada (x, y).

Exemplos:

```{r}
atb <- tibble(
  id        = c( 1L,  2L,  3L,  4L),
  name      = c("A", "B", "C", "D"),
  duration  = c( 2L,  3L,  1L,  2L)
)
rtb <- tibble(
  from = c(1L, 2L, 4L, 4L),
  to   = c(3L, 3L, 1L, 2L)
)
sch <- sch_new() %>% 
  sch_title("A project") %>% 
  sch_reference("From criticalpath") %>% 
  sch_add_activities_tibble(atb) %>% 
  sch_add_relations_tibble(rtb) %>% 
  sch_plan()

gantt <- sch_gantt_matrix(sch)
gantt

# Qual é o esforço total no período?
colSums(gantt) # 1 1 2 2 1 1

# Qual é a duração de cada uma das atividades?
rowSums(gantt) # 2 3 1 2

# Como criar uma Curva S?
cumsum(colSums(gantt))
plot(cumsum(colSums(gantt)), type="l", lwd=3)
xyw <- sch_xy_gantt_matrix(sch)
xyw
plot(xyw[, 1:2])
```


# Como mudar a duração das atividades

Uma das ferramentas e técnicas do gerenciamento de cronogramas é a análise "E-se?". Essa funcionalidade do pacote `criticalpath` permite fazer justamente a análise "E-se?" através da alteração da duração de todas as atividades ao mesmo. A forma implementada aqui é mais rápida do que criar todo o cronograma novamente.

**Atenção:** O vetor com as novas durações das atividades deve estar ordenados
pela ordem de inclusão das atividades.

- **Utilização:** `sch_change_durations(new_durations)`

```{r}
atb <- tibble(
  id        = 1:17,
  name      = paste("a", as.character(1:17), sep=""),
  duration  = c(1L,1L,3L,2L, 2L,2L,2L,1L, 4L,5L,3L,3L, 4L,5L,1L,5L,2L)
)

rtb <- tibble(
  from = c(1L, 2L, 3L, 3L, 4L, 5L, 6L, 7L, 8L,  8L, 8L,
    8L,  8L,  9L, 10L, 11L, 12L, 13L, 13L, 14L, 14L, 15L, 15L),
  to   = c(2L, 3L, 4L, 6L, 5L, 8L, 7L, 8L, 9L, 10L, 11L,
   12L, 13L, 14L, 14L, 14L, 14L, 14L, 15L, 16L, 17L, 16L, 17L)
)

sch <- sch_new() %>% 
  sch_title("Project 2: Patient Transport System") %>% 
  sch_reference(
    "VANHOUCKE, Mario. Integrated project management and control:
    first comes the theory, then the practice. Gent: Springer, 2014, p. 9") %>% 
  sch_add_activities_tibble(atb) %>% 
  sch_add_relations_tibble(rtb) %>% 
  sch_plan()
  
#Project duration
sch_duration(sch) # 25
#Activities duration
sch_activities(sch)$duration

new_durations <- c(1L,2L,5L, 4L,3L, 2L,1L, 5L, 3L,5L,5L,3L,4L, 2L,1L, 2L,4L)
sch %<>%
  sch_change_activities_duration(new_durations)

#Project duration
sch_duration(sch) # 31
#Activities duration
sch_activities(sch)$duration

```


# Como recuperar as propriedades dos relacionamentos

Vimos, anteriormente, as propriedades das atividades disponíveis. Agora iremos estudar as propriedadas dos relacionamentos. Na sequência, veremos como recuperar os predecessores e os sucessores de uma atividade, ainda saber se um relacionamento é redundante ou não.

## Propriedades dos relacionamentos

Existem vários métodos sobre os relacionamentos que você pode utilizar para recuperar informações sobre eles. Após incluir atividades e relacionamentos num cronogram, você pode querer saber quantos relacionamentos o cronograma possui ou então, quais desses relacionamentos pertencem ao caminho crítico. Vamos às explicações dessas propriedades.

- **Has Any Relation:** Valor lógico que indica se o cronograma possui algum relacionamento ou não.
  - `TRUE`: indica que o cronograma tem pelo menos um relacionamento;
  - `FALSE`: indica que o cronograma não possui nenhum relacionamento.
  - Utilização: `sch_has_any_relation`

- **Number of Relations:** Informa o número de relacionamentos que o cronograma possui.
   - Utilização: `sch_nr_relations`

- **Relations:** Retorna um tibble com todas os relacionamentos do cronograma, obedecendo a ordem topológica entre eles. A ordem topológica obedece a relação de precedência do diagrama de rede delas. Esta é a outra principal informação calculada pelo CPM. O tibble tem a seguinte estrutura:
   - **from:** Identificador da atividade predecessora da relação.
   - **to:** identificador da atividade sucessora da relação.
   - **type:** Tipo do relacionamento entre as atividades. Seu valor pode ser: FS, FF, SS, SF, conforme já descrito anteriormente.
   - **lag:** Período de tempo entre atividade predecessora e a sucessora.
   - **critical:** Indica se o relacionamento é crítico ou não. Um relacionamento é crítico se ele for formado por duas atividades críticas.
     - `TRUE`: indica que o relacionamento é crítico;
     - `FALSE`: indica que o relacionamento não é crítico.
   - **ord:** É a ordem em que os relacionamentos foram incluídos no cronograma.
   - **i_from:** Índice da atividade predecessora lá no tibble de atividades.
   - **i_to:** Índice da atividade sucessora lá no tibble de atividades.

   - Utilização: `sch_relations`

```{r}
# Criar um cronograma
sch <- sch_new() %>% 
  sch_title("Fictitious Project Example") %>% 
  sch_reference("VANHOUCKE, Mario. Measuring time:
  improving project performance using earned value management.
  Gent: Springer, 2009, p. 18") 

sch_has_any_relation(sch)  # FALSE
sch_nr_relations(sch)      # 0

# Inclui atividades e relacionamentos no cronograma.
sch %<>% 
  sch_add_activity(  1L, "a1" , 0L, 2L,3L,4L) %>% 
  sch_add_activity(  2L, "a2" , 4L, 5L) %>% 
  sch_add_activity(  3L, "a3" , 9L, 10L) %>% 
  sch_add_activity(  4L, "a4" , 1L, 6L) %>% 
  sch_add_activity(  5L, "a5" , 4L, 9L) %>% 
  sch_add_activity(  6L, "a6" , 5L, 7L) %>% 
  sch_add_activity(  7L, "a7" , 1L, 8L,11L) %>% 
  sch_add_activity(  8L, "a8" , 7L, 12L) %>% 
  sch_add_activity(  9L, "a9" , 8L, 12L) %>% 
  sch_add_activity( 10L, "a10", 3L, 12L) %>% 
  sch_add_activity( 11L, "a11", 3L, 12L) %>% 
  sch_add_activity( 12L, "a12", 0L)

sch_has_any_relation(sch)  # TRUE
sch_nr_relations(sch)      # 14

sch_relations(sch)
```


## Atividades predecessoras e sucessoras

Um cronograma é formado por atividades e o relacionamento entre elas. Isso significa que cada atividade pode ter zero, um ou mais predecessoras e sucessoras. Além disso, uma relação pode ser redundante. Os próximos comandos mostram como recuperar essas informações do cronograma.

- **All Successors:** Lista todas as sucessoras diretas e indiretas de uma atividade.
   - Utilização: `sch_all_successors(id, ign_to=NULL)`
     - **id**: Identificador da atividade a ser inspecionada.
     - **ign_to**: Relação a ser ignorada na listagem: id -> ign_to. Atividades que pertencem a essa relação serão ignoradas.

- **All Predecessors:** Lista todas as predecessoras diretas e indiretas de uma atividade.
   - Utilização: `sch_all_predecessors(id, ign_from=NULL)`
     - **id**: Identificador da atividade a ser inspecionada.
     - **ign_from**: Relação a ser ignorada na listagem: ign_from -> id. Atividades que pertencem a essa relação serão ignoradas.

- **Is Redundant:** Verifica se a relação entre duas atividades é redundante. Uma relação `A->C` é redudante se existirem as seguintes relações: `A->C, A->, B->C`. Ela retorna um valor lógico.
   - Utilização: `sch_is_redundant(id_from, id_to)`
     - **id_from**: identificar da atividade predecessora.
     - **id_to**: identificar da atividade sucessora.
   - Retorno:
     - `TRUE`: se o relacionamento é redundante;
     - `FALSE`: se o relacionamento não é redundante.

```{r}
# Criar o cronograma
sch <- sch_new() %>% 
  sch_title("Fictitious Project Example") %>% 
  sch_reference("VANHOUCKE, Mario. Measuring time:
  improving project performance using earned value management.
  Gent: Springer, 2009, p. 18") %>% 
# Incluir atividades e relacionamentos no cronograma
  sch_add_activity(  2L, "a2" , 4L, 5L, 12L) %>% 
  sch_add_activity(  3L, "a3" , 9L, 10L) %>% 
  sch_add_activity(  4L, "a4" , 1L, 6L) %>% 
  sch_add_activity(  5L, "a5" , 4L, 9L) %>% 
  sch_add_activity(  6L, "a6" , 5L, 7L) %>% 
  sch_add_activity(  7L, "a7" , 1L, 8L,11L) %>% 
  sch_add_activity(  8L, "a8" , 7L, 12L) %>% 
  sch_add_activity(  9L, "a9" , 8L, 12L) %>% 
  sch_add_activity( 10L, "a10", 3L, 12L) %>% 
  sch_add_activity( 11L, "a11", 3L, 12L) %>% 
  sch_add_activity( 12L, "a12", 0L) %>% 
  sch_plan()

sch_all_successors(sch, 2) # 5, 9, 12
sch_all_successors(sch, 7) # 8, 11, 12
sch_all_successors(sch, 10) # 12

sch_all_predecessors(sch, 2) # nothing
sch_all_predecessors(sch, 7) # 6, 4
sch_all_predecessors(sch, 10) # 3

sch_is_redundant(sch, 2, 5)  #FALSE
sch_is_redundant(sch, 2, 12) #TRUE

```



# Como recupearar as propriedades topológicas

## Indicadores topológicos

Mostra informações sobre a estrutura da rede. Eles podem ser de quatro tipos:

**SP Serial or Parallel:** Mostra o quão próximo é uma rede de ser sequencial ou paralela. 
A medida que uma rede se torna serial, o SP aumenta, até chegar em um, quanto ela é totalmente sequencial.

   - Utilização:

   `sch_topoi_sp()`

**AD Activity Distribution:** Mede a distribuição das atividades em seus níveis. Se o AD é aproximadamente igual a zero, a quantidade de atividades de cada nível não é distribuída uniformemente.

   - Utilização:
   
   `sch_topoi_ad()`

**LA Length of Arcs:** Mede a presença de arcos longos, baseados na diferença entre o nível progressivel da atividade predecessora e a sua sucessora. Se o LA é aproximadamente igual a zero, o nível progressivo entre as atividades é o mais longe possível. De outro modo, se o LA é igual a um, a distância entre as relações é um.

   - Utilização: 
   
   `sch_topoi_la()`

**TF Topological Float Indicator:** Mede a folga topológica entre cada atividade. Se TF for igual a zero, não existe folga entre as atividades. Se o TF igual a um, existem folgas entre as atividades e elas podem ser deslocadas sem afetar suas atividades sucessoras.

   - Utilização: 
   
   `sch_topoi_tf()`

```{r}
# Cria um cronograma
sch <- sch_new() %>% 
  sch_title("Fictitious Project Example") %>% 
  sch_reference("VANHOUCKE, Mario. Measuring time:
    improving project performance using earned value management.
    Gent: Springer, 2009, p. 18") %>% 
# Inclui atividades e o relacionamento entre elas.
  sch_add_activity( 1L, "a1" , 0L, 2L,3L,4L) %>% 
  sch_add_activity( 2L, "a2" , 4L, 5L) %>% 
  sch_add_activity( 3L, "a3" , 9L, 10L) %>% 
  sch_add_activity( 4L, "a4" , 1L, 6L) %>% 
  sch_add_activity( 5L, "a5" , 4L, 9L) %>% 
  sch_add_activity( 6L, "a6" , 5L, 7L) %>% 
  sch_add_activity( 7L, "a7" , 1L, 8L,11L) %>% 
  sch_add_activity( 8L, "a8" , 7L, 12L) %>% 
  sch_add_activity( 9L, "a9" , 8L, 12L) %>% 
  sch_add_activity(10L, "a10", 3L, 12L) %>% 
  sch_add_activity(11L, "a11", 3L, 12L) %>% 
  sch_add_activity(12L, "a12", 0L) %>% 
  sch_plan()

sch_topoi_sp(sch)
sch_topoi_ad(sch)
sch_topoi_la(sch)
sch_topoi_tf(sch)
```


# Conclusão

Bom, foi uma grande jornada, mas valeu a pena!

# Referências

Csardi, G. & Nepusz, T. (2005).
The Igraph Software Package for Complex Network Research.
*InterJournal*. Complex Systems. 1695.
[Article](https://www.researchgate.net/publication/221995787_The_Igraph_Software_Package_for_Complex_Network_Research) / [igraph](https://igraph.org/)

Project Management Institute (2017).
**A Guide to the Project Management Body of Knowledge (PMBOK Guide)**.
Sixth Edition.
[PMBOK](https://www.pmi.org/pmbok-guide-standards/foundational/pmbok)

Project Management Institute (2017).
**PMI Lexicon of Project Management Terms:** Version 3.2.
[PMI Lexicon](https://www.pmi.org/pmbok-guide-standards/lexicon)

Rosa, Rubens Jose; Santos, Marcos dos; Marques, Thiago (2021). **criticalpath**: An
  Implementation of the Critical Path Method. R package version 0.0.0.9010.
  [https://rubensjoserosa.com/criticalpath](https://rubensjoserosa.com/criticalpath).


Vanhoucke, M. (2009) **Measuring Time**:
Improving Project Performance Using Earned Value Management.
Springer-Verlag US.
[doi://10.1007/978-1-4419-1014-1](https://doi.org/10.1007/978-1-4419-1014-1).

Vanhoucke, M. (2013) **Project Management with Dynamic Scheduling**:
Baseline Scheduling, Risk Analysis and Project Control.
Springer-Verlag Berlin Heidelberg.
[doi://10.1007/978-3-642-40438-2](https://doi.org/10.1007/978-3-642-40438-2)

Vanhoucke, M. (2014) **Integrated Project Management and Control**:
First Comes the Theory, then the Practice.
Springer International Publishing Switzerland.
[doi://10.1007/978-3-319-04331-9](https://doi.org/10.1007/978-3-319-04331-9)

